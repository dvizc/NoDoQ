# Contracts folder â€” NoDo


## Contenido:
- IVerifier.sol -> interface expected from an on-chain verifier (PLONK, etc.)
- VerifierStub.sol -> a development stub that returns `true` for any proof (replace in prod)
- NoDoAnchor.sol -> main anchoring contract: anchors batch root + batchHash; optionally verifies ZK proof


## Notas importantes:
- The VerifierStub is provided only for local testing and development on testnets. Replace it with the
actual on-chain verifier generated by your ZK toolchain (snarkjs or other). Typical flow:
1. Generate the proving/verifier artifacts with snarkjs (zkey, verifier.sol etc.).
2. Compile and deploy the real verifier contract.
3. Call `setVerifier(realVerifierAddress)` and optionally `setRequireProof(true)` on the NoDoAnchor contract.


- `anchorVoteBatch` accepts:
- `proof` (bytes) and `pubSignals` (uint256[])
- `root` (bytes32) and `batchHash` (bytes32)
- `metadata` (string) for human-readable pointer (IPFS CID or similar)
If proofs are required, the contract will call `verifier.verify(proof, pubSignals)` and revert if invalid.


- For PLONK specifically: the verifier generated by snarkjs may have a different function signature
(for instance `verifyProof(uint[...], uint[...])` or `verify(bytes, uint[])`). Adapt the IVerifier
interface to match the generated verifier's public function signature.


- Security: minimize on-chain data, store only minimal references (roots, hashes, IPFS CIDs). Proofs and
large artifacts should be kept off-chain (IPFS/Arweave) and linked by `batchHash`.
